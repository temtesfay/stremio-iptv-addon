export type StringOrNull = string | null;
export type M3uParserOptions = {
    userAgent?: string;
    timeout?: number;
};
export interface StreamInfo {
    name: StringOrNull;
    logo: StringOrNull;
    url: StringOrNull;
    category: StringOrNull;
    live?: boolean;
    tvg: {
        id: StringOrNull;
        name: StringOrNull;
        url: StringOrNull;
    };
    country: {
        code: StringOrNull;
        name: StringOrNull;
    };
    language: {
        code: StringOrNull;
        name: StringOrNull;
    };
}
export interface Parser {
    filterBy: (key: string, filters: string[] | boolean[], retrieve?: boolean, nestedKey?: boolean, keySplitter?: string) => void;
    sortBy: (key: string, asc?: boolean, nestedKey?: boolean, keySplitter?: string) => void;
    parseM3u: (fileOrPath: string | File, checkLive?: boolean) => Promise<void>;
    saveToFile: (fileNameOrPath: string, format?: string) => Promise<void>;
    removeByExtension: (extensions: string[]) => void;
    retrieveByCategory: (category: string[] | boolean[]) => void;
    getRandomStream: (shuffle?: boolean) => StreamInfo;
    getStreamsInfo: () => StreamInfo[];
    resetOperations: () => void;
    getJSON: () => string;
}
/**A parser for m3u files.
 *
 * It parses the contents of m3u file to a list of streams information which can be saved as a JSON/M3U file.
 * ```
 *  import { M3uParser } from "@pawanpaudel93/m3u-parser"
 
    const userAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36"
    const parser = new M3uParser(userAgent);
    (async () => {
        await parser.parseM3u("https://iptv-org.github.io/iptv/countries/np.m3u")
        console.log(parser.getStreamsInfo())
    })();
 * ```
 */
export declare class M3uParser implements Parser {
    protected streamsInfo: StreamInfo[];
    protected streamsInfoBackup: StreamInfo[];
    protected lines: string[];
    protected checkLive: boolean;
    protected content: string;
    protected timeout: number;
    protected userAgent: string;
    protected isNodeJS: boolean;
    protected regexes: {
        tvgName: RegExp;
        tvgID: RegExp;
        tvgLogo: RegExp;
        tvgURL: RegExp;
        tvgCountry: RegExp;
        tvgLanguage: RegExp;
        groupTitle: RegExp;
        title: RegExp;
        streams: RegExp;
        file: RegExp;
    };
    constructor(options?: M3uParserOptions);
    protected axiosGet(url: string): Promise<import("axios").AxiosResponse<any, any>>;
    protected parseLines(): Promise<void>;
    protected getValue(line: string, type: string): string | null;
    protected parseLine(lineNumber: number, resolve: () => void): Promise<void>;
    protected getM3U(): string;
    protected getShuffledArr: (arr: StreamInfo[]) => StreamInfo[];
    /**Parses the content of local file/URL.
     *
     * It downloads the file from the given url or use the local file path to get the content or read the file in the browser and parses line by line to a structured format of streams information.
     * @param {string | File} fileOrPath - Path/URL to the M3U file or file itself in browser.
     * @param {boolean} [checkLive=true] - Check if the stream is live
     * @returns {Promise<void>} - Promise that resolves when the file is parsed
     */
    parseM3u(fileOrPath: string | File, checkLive?: boolean): Promise<void>;
    /**Save to file (JSON or M3U)
     *
     * It saves streams information as a JSON, or M3U file with a given filename and format parameters.
     * @param {string} fileNameOrPath - Path or file name to save the file.
     * @param {string} [format='json'] - Format of the file to save. Can be 'json' or 'm3u'.
     * @returns {void}
     */
    saveToFile(fileNameOrPath: string, format?: string): Promise<void>;
    /**Get the streams information as json
     * @param {number} [indent=4] - Indentation level
     * @returns {string} - JSON string of the parsed M3U file
     */
    getJSON(indent?: number): string;
    /**Get the parsed streams information list.
     * @returns {StreamInfo[]} - Array of StreamInfo objects
     */
    getStreamsInfo(): StreamInfo[];
    /**Reset the stream information list to initial state before various operations.
     * @returns {void}
     */
    resetOperations(): void;
    /**Filter streams information.
     *
     * It retrieves/removes stream information from streams information list using filters on key.
     * If key is not found, it will not raise error and filtering is done silently.
     * @param {string} key - Key can be single or nested. eg. key='name', key='language-name'
     * @param {string[]| boolean[]} filters - List of filters to perform the retrieve or remove operation.
     * @param {boolean} [retrieve=true] - True to retrieve and False for removing based on key.
     * @param {boolean} [nestedKey=false] - True/False for if the key is nested or not.
     * @param {string} [keySplitter='-'] - A splitter to split the nested keys. Default: "-"
     * @returns {void}
     */
    filterBy(key: string, filters: string[] | boolean[], retrieve?: boolean, nestedKey?: boolean, keySplitter?: string): void;
    /**Retrieve only streams information with certain extensions.
     *
     * It retrieves the stream information based on extensions provided.
     * @param {string[]} extensions - List of extensions like mp4, m3u8 etc.
     * @returns {void}
     */
    retrieveByExtension(extensions: string[]): void;
    /**Removes streams information with certain extensions.
     *
     * It removes stream information based on extensions provided.
     * @param {string[]} extensions - List of extensions like mp4, m3u8 etc.
     * @returns {void}
     */
    removeByExtension(extensions: string[]): void;
    /**Retrieve only streams information with certain categories.
     *
     * It retrieves stream information based on categories provided.
     * @param {string[]|boolean[]} categories - List of categories to perform the retrieve or remove operation.
     */
    retrieveByCategory(categories: string[] | boolean[]): void;
    /**Removes streams information with certain categories.
     *
     * It removes stream information based on categories provided..
     * @param {string[]|boolean[]} categories - List of categories to perform the retrieve or remove operation.
     */
    removeByCategory(categories: string[] | boolean[]): void;
    /**Sort streams information.
     *
     * It sorts streams information list sorting by key in asc/desc order.
     * @param {string} key - Key to sort by. It can be single or nested key.
     * @param {boolean} [asc=true] - True for ascending and False for descending.
     * @param {boolean} [nestedKey=false] - True/False for if the key is nested or not.
     * @param {string} [keySplitter='-'] - A splitter to split the nested keys. Default: "-"
     * @returns {void}
     */
    sortBy(key: string, asc?: boolean, nestedKey?: boolean, keySplitter?: string): void;
    /**Return a random stream information
     *
     * It returns a random stream information with shuffle if required.
     * @param {boolean} [shuffle=true] - True to shuffle and False for not.
     * @returns {StreamInfo} - Stream information object.
     */
    getRandomStream(shuffle?: boolean): StreamInfo;
}
